rm(list = ls())
# Change the working directory
wd <- "/home/david/ownCloud/University/15. PhD/Chapter_1"
setwd(wd)
# Load required packages
library(tidyverse)    # For data wrangling
library(raster)       # For handling spatial data
library(rgdal)        # For handling spatial data
################################################################################
#### Putting Data Together
################################################################################
# Identify all simulation files
files <- dir(
"03_Data/03_Results/99_Simulations"
, pattern     = ".rds$"
, full.names  = T
)
# Load the files and bind their rows together
sims <- lapply(1:length(files), function(x){
dat <- read_rds(files[x])
dat$SimID <- x
return(dat)
}) %>% do.call(rbind, .)
# Take a look at the data
head(sims)
# Count the number of simulated steps (in Mio)
nrow(sims) / 1e6
# Because in each simulation we start off with new IDs for trajectories, they
# are not unique across simulations. We thus combine ID and SimID to create an
# ID that is unqiue to each simulated path, across all simulations
sims <- sims %>% mutate(TrackID = group_indices(., SimID, TrackID))
# Make sure it worked
table(table(sims$TrackID))
# Collect garbage
gc()
# Let's also create a step counter, indicating the number of the step in its
# respective trajectory
sims <- sims %>% group_by(TrackID) %>% mutate(StepNumber = (row_number()))
head(sims)
# Check object size
format(object.size(sims), units = "Gb")
# Write to an rds
write_rds(sims, "03_Data/03_Results/99_DispersalSimulationSub.rds")
sim2tracks <- function(simulation = NULL, steps = 68){
if (steps < nrow(simulation)){
steps <- steps + 1
}
sub <- simulation[1:steps, ]
pts <- sub
coordinates(pts) <- c("x", "y")
line <- spLines(pts)
lines <- createSegments(pts)
lines@data <- sub[1:(steps - 1), ]
return(lines)
}
# Function to convert a simulated track to a spatial lines object
sim2tracks <- function(simulation = NULL, steps = 68, keep.data = F){
# Add one more "step" if possible
if (steps < nrow(simulation)){
steps <- steps + 1
}
sub <- simulation[1:steps, ]
# If data does not need to be kept
if (!keep.data){
coordinates(sub) <- c("x", "y")
crs(sub) <- CRS("+init=epsg:4326")
lines <- spLines(sub)
return(lines)
# If data needs to be kept
} else {
pts <- sub
coordinates(pts) <- c("x", "y")
line <- spLines(pts)
lines <- createSegments(line)
lines <- as(lines, "SpatialLinesDataFrame")
lines@data <- sub[1:(steps - 1), ]
return(lines)
}
}
createSegments <- function(x){
# Get coordinates along line. Pair each segment's coordinates
coords <- coordinates(x)
coords <- as.data.frame(coords)
names(coords) <- c("x", "y")
coords$x_to <- lead(coords$x)
coords$y_to <- lead(coords$y)
coords <- na.omit(coords)
# Coerce coordinates to spatial lines
lines <- apply(coords, 1, function(z){
l <- spLines(
rbind(
SpatialPoints(cbind(z["x"], z["y"]))
, SpatialPoints(cbind(z["x_to"], z["y_to"]))
)
)
return(l)
})
lines <- do.call(rbind, lines)
# Add coordinates as data to each line
lines <- SpatialLinesDataFrame(lines, data = coords, match.ID = F)
# Return the final object
return(lines)
}
createSegments2 <- function(x){
# Identify its coordinates
multil <- coordinates(x) %>%
# Convert to data frame
as.data.frame() %>%
# Rename columns
setNames(c("x", "y")) %>%
# Make sure from-to coordinates are in one row
mutate(x_to = lead(x)) %>%
mutate(y_to = lead(y)) %>%
# Remove na rows
na.omit() %>%
# Split each row into a list entry
split(seq(nrow(.))) %>%
# Coerce each row to a separate line
lapply(function(z){
l <- spLines(rbind(
SpatialPoints(data.frame(x = z$x, y = z$y))
, SpatialPoints(data.frame(y = z$x_to, x = z$y_to))
))
l <- SpatialLinesDataFrame(l, data = z, match.ID = F)
return(l)
}) %>% do.call(rbind, .)
# Return this new multiline object
return(multil)
}
library(profvis)
library(microbenchmark)
install.packages("profvis")
library(profvis)
profvis({
sim2tracks(subset(sims, TrackID == 1), keep.data = F)
})
help("profvis")
sub <- subset(sims, TrackID == 1)
profvis({
sim2tracks(sub, keep.data = F)
})
