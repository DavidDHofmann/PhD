, shape = (params$GammaMean[s] / params$GammaSD[s]) ** 2
, scale = params$GammaSD[s] ** 2 / params$GammaMean[s]
)
# Sample (relative) turning angles from the state-specific von mises
# distribution
df$relta[i] <- rvonmises(1
, mu    = params$MisesMean[s]
, kappa = params$MisesCon[s]
)
# Compute the absolute turning angle
df$absta[i] <- absta_init + df$relta[i]
# Compute the new location of the animal
df$x[i + 1] <- df$x[i] + sin(df$absta[i]) * df$stepl[i]
df$y[i + 1] <- df$y[i] + cos(df$absta[i]) * df$stepl[i]
# Store other relevant information
df$food[i]  <- f
df$state[i] <- s
absta_init  <- df$absta[i]
state_init  <- df$state[i]
}
# Return the simulation
return(df)
})
# Look at the final object
print(sims, n = 5)
# Unnest the data
sims <- unnest(sims, Simulations)
# Take a look at the unnested data
head(sims)
# Visualize it
ggplot() +
geom_raster(data = as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
scale_fill_viridis_c() +
geom_point(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.2) +
geom_path(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.2) +
coord_equal() +
theme_minimal() +
theme(legend.position = "none")
# Visualize it
ggplot() +
geom_raster(data = as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
scale_fill_viridis_c() +
geom_point(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.5) +
geom_path(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.5) +
coord_equal() +
theme_minimal() +
theme(legend.position = "none")
# Prepare the data
df_prep <- prepData(as.data.frame(sims[, c("ID", "x", "y", "food")])
, type       = "UTM"
, coordNames = c("x", "y")
)
# Define initial values for step length distribution
hist(df_prep$step)
# Define initial values for step length distribution
hist(df_prep$step)
mu0 <- c(5, 10)
sd0 <- c(5, 10)
stepPar <- c(mu0, sd0)
# Define intial values for turning angle distribution
hist(df_prep$angle)
anglemean0 <- c(0, 0)
anglecon0 <- c(0.5, 1)
anglePar <- c(anglemean0, anglecon0)
# Fit the model
mod <- fitHMM(
data      = df_prep
, nbStates  = 2
, stepPar0  = stepPar
, anglePar0 = anglePar
, formula   = ~ food
)
# Check the results
mod
# Compare model estimates to true parameters
list(mod$mle$stepPar, t(params[, c("Mode", "GammaMean", "GammaSD")]))
# Compare model estimates to true parameters
list(mod$mle$stepPar, t(params[, c("State", "GammaMean", "GammaSD")]))
list(mod$mle$anglePar, t(params[, c("State", "MisesMean", "MisesCon")]))
list(mod$mle$beta, t(params[, c("Mode", "T_int", "T_beta")]))
list(mod$mle$beta, t(params[, c("Mode", "T_a", "T_b")]))
list(mod$mle$beta, t(params[, c("State", "T_a", "T_b")]))
# Compare states
states <- viterbi(mod)
cbind(sims$state, states)
# Compare states
states <- viterbi(mod)
cbind(sims$state, states)
cor(sims$state, states, use = "pairwise.complete.obs")
# Confusion matrix
table(sims$state, states)
# Plot the states
plotStates(mod, animals = "1")
# Plot transition probs
plotStationary(mod, plotCI = T)
cbind
as.data.frame(food, xy = T)
# Simulate a resource (determines the likelihood of switching states)
food <- raster(ncol = 500, nrow = 500, xmn = 0, xmx = 1000, ymn = 0, ymx = 1000)
library(raster)
library(NLMR)
# Simulate a resource (determines the likelihood of switching states)
food <- raster(ncol = 500, nrow = 500, xmn = 0, xmx = 1000, ymn = 0, ymx = 1000)
food[] <- values(nlm_gaussianfield(ncol = 500, nrow = 500))
ggplot(as.data.frame(food, xy = T), aes(x = x, y = y, fill = )) +
geom_raster()
# Simulate a resource (determines the likelihood of switching states)
library(tidyverse)
as.data.frame(food, xy = T)
# Simulate a resource (determines the likelihood of switching states)
food <- raster(ncol = 500, nrow = 500, xmn = 0, xmx = 1000, ymn = 0, ymx = 1000)
food[] <- values(nlm_gaussianfield(ncol = 500, nrow = 500))
food <- scale(food)
plot(food)
ggplot(as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
geom_raster()
ggplot(as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
geom_raster() +
scale_fill_viridis_c() +
coord_equal() +
theme_minimal() +
theme(legend.position = "bottom")
ggplot(as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
geom_raster() +
scale_fill_viridis_c() +
coord_equal() +
theme_minimal()
ggplot(as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
geom_raster() +
scale_fill_viridis_c(name = "Food Availability") +
coord_equal() +
theme_minimal()
# Visualize it
ggplot() +
geom_raster(data = as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
scale_fill_viridis_c(name = "Food Availability") +
geom_point(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.5) +
geom_path(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.5) +
coord_equal() +
theme_minimal() +
guides(colour = "none")
df_prep$step
library(tidyverse)   # For easier data handling
library(NLMR)        # To simulate landscapes
library(raster)      # To handle spatial data
library(moveHMM)     # To analyse the simulated data
library(ggpubr)      # To arrange multiple ggplot objects
# Simulate a resource (determines the likelihood of switching states)
food   <- raster(ncol = 500, nrow = 500, xmn = 0, xmx = 1000, ymn = 0, ymx = 1000)
food[] <- values(nlm_gaussianfield(ncol = 500, nrow = 500))
food   <- scale(food)
# Visualize it
ggplot(as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
geom_raster() +
scale_fill_viridis_c(name = "Food Availability") +
coord_equal() +
theme_minimal()
# Visualize it
ggplot(as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
geom_raster() +
scale_fill_viridis_c(name = "Food Availability") +
coord_equal() +
theme_minimal() +
theme(legend.position = "bottom")
# Visualize it
ggplot(as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
geom_raster() +
scale_fill_viridis_c(name = "Food Availability") +
coord_equal() +
theme_minimal() +
theme(legend.position = "bottom") +
guides(fill = guide_colourbar(title.position="top", title.hjust = 0.5))
# Chunk 2
# Load required packages
library(tidyverse)   # For easier data handling
library(NLMR)        # To simulate landscapes
library(raster)      # To handle spatial data
library(moveHMM)     # To analyse the simulated data
library(ggpubr)      # To arrange multiple ggplot objects
# Chunk 3
# Simulate a resource (determines the likelihood of switching states)
food   <- raster(ncol = 500, nrow = 500, xmn = 0, xmx = 1000, ymn = 0, ymx = 1000)
food[] <- values(nlm_gaussianfield(ncol = 500, nrow = 500))
food   <- scale(food)
# Visualize it
ggplot(as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
geom_raster() +
scale_fill_viridis_c(name = "Food Availability") +
coord_equal() +
theme_minimal() +
theme(legend.position = "bottom") +
guides(fill = guide_colourbar(title.position="top", title.hjust = 0.5))
# Chunk 4
# Simulate step lengths for two hypothetical states
states <- tibble(
State = rep(c("State 1", "State 2"), each = 500)
, Shape = ifelse (State == "State 1", 2.5, 3.0)
, Scale = ifelse (State == "State 1", 0.5, 1.5)
, StepLength = NA
)
for (i in 1:nrow(states)) {
states$StepLength[i] <- rgamma(1, shape = states$Shape[i], scale = states$Scale[i])
}
# Visualize
ggplot(states, aes(x = StepLength)) +
geom_histogram(col = "white", bins = 20, fill = "cornflowerblue") +
theme_minimal() +
facet_wrap(~ State)
# Chunk 5
# Function to determine the probability density of a von Mises distribution
dvonmises <- function(x, kappa, mu, log = F) {
d <- exp(kappa * cos(x - mu)) / (2 * pi * besselI(kappa, nu = 0))
if (log == T) {
d <- log(d)
}
return(d)
}
# Function to randomly sample values from a von Mises distribution
rvonmises <- function(n, kappa, mu, by = 0.01) {
x <- seq(-pi, +pi, by = by)
probs <- dvonmises(x, kappa = kappa, mu = mu)
random <- sample(x, size = n, prob = probs, replace = T)
return(random)
}
# Simulate turning angles for two hypothetical states
states <- tibble(
State = rep(c("State 1", "State 2"), each = 500)
, Kappa = ifelse (State == "State 1", 0.2, 0.5)
, Mu    = 0
, TurningAngle = NA
)
for (i in 1:nrow(states)) {
states$TurningAngle[i] <- rvonmises(1, kappa = states$Kappa[i], mu = states$Mu[i])
}
# Visualize
ggplot(states, aes(x = TurningAngle)) +
geom_histogram(col = "white", bins = 20, fill = "cornflowerblue") +
theme_minimal() +
facet_wrap(~ State)
# Chunk 6
# Function to compute the transition probability, depending on food-availability
# and parameters a and b
transition <- function(food, a, b) {
linear_predictor <- a + b * food
1 / (1 + exp(-linear_predictor)) # Inverse logit
}
# Generate transition probability for different food-availability
tr <- tibble(
Food = seq(-4, 4, by = 0.01)
, TransitionProbability = transition(Food, a = 1, b = 2)
)
# Function to sample a state
sample_state <- function(state, food) {
p <- transition(food, params$T_a[state], params$T_b[state])
change <- rbinom(n = 1, size = 1, prob = p)
if (state == 1 & change == 1) {
state <- 2
} else if (state == 2 & change == 1) {
state <- 1
}
return(state)
}
# Visualize
ggplot(tr, aes(x = Food, y = TransitionProbability)) +
geom_line(col = "cornflowerblue", lwd = 1.2) +
theme_minimal()
# Chunk 7
# Number of steps to simulate
n_steps <- 100
# Number of individuals to simulate
n_indivs <- 100
# Create tibble (a fancy dataframe) into which we will store the results
sims <- tibble(ID = 1:n_indivs)
# Movement parameters
params <- tibble(
State     = c("Resting", "Moving")
, GammaMean = c(5, 15)   # Mean of the gamma distribution
, GammaSD   = c(5, 10)   # Standard deviation of the gamma distribution
, MisesMean = c(0, 0)    # Mean (location) of the von Mises distribution
, MisesCon  = c(0.5, 1)  # Concentration parameter of the von Mises distribution
, T_a       = c(1, 2)    # Intercept of the linear predictor for transition probs.
, T_b       = c(-1, 4)   # Slope of the linear predictor for transition probs.
)
# Take a look at them
params
# Chunk 8
# Compute probability density functions for step lengths, turning angles, and
# transition probabilities for the given simulation parameters
example <- params %>%
mutate(StepLengths = map2(GammaMean, GammaSD, function(x, y) {
tibble(
StepLength = seq(0, 60, length.out = 1000)
, Density    =  dgamma(StepLength, shape = (x / y) ** 2, scale = y ** 2 / x)
)
})) %>%
mutate(TurningAngles = map2(MisesCon, MisesMean, function(x, y) {
tibble(
TurningAngle = seq(-pi, +pi, length.out = 1000)
, Density      = dvonmises(TurningAngle, kappa = x, mu = y)
)
})) %>%
mutate(Transitions = map2(T_a, T_b, function(x, y) {
tibble(
Food = seq(-4, +4, length.out = 1000)
, Density = transition(Food, x, y)
)
}))
# Visualize
p1 <- example %>%
unnest(StepLengths) %>%
ggplot(aes(x = StepLength, y = Density)) +
geom_line(col = "cornflowerblue", lwd = 1.2) +
facet_wrap(~State) +
theme_minimal()
p2 <- example %>%
unnest(TurningAngles) %>%
ggplot(aes(x = TurningAngle, y = Density)) +
geom_line(col = "cornflowerblue", lwd = 1.2) +
facet_wrap(~State) +
theme_minimal()
p3 <- example %>%
unnest(Transitions) %>%
ggplot(aes(x = Food, y = Density)) +
geom_line(col = "cornflowerblue", lwd = 1.2) +
facet_wrap(~State) +
theme_minimal() +
ylab("TransitionProbability")
# Put the plots together
ggarrange(p1, p2, p3, nrow = 3)
# Chunk 9
# Run simulations
sims$Simulations <- lapply(1:nrow(sims), function(x) {
# Generate dataframe to keep track of coordinates and other data
df <- data.frame(
x     = rep(NA, n_steps) # x-coordinate
, y     = rep(NA, n_steps) # y-coordinate
, stepl = rep(NA, n_steps) # Step length
, relta = rep(NA, n_steps) # Relative turning angle (heading / orientation)
, absta = rep(NA, n_steps) # Absolute turning angle
, state = rep(NA, n_steps) # Current state
, food  = rep(NA, n_steps) # Food-availability
)
# Specify an initial orientation and state
absta_init <- 0
state_init <- 1
# Initiate first rows of the dataframe (animal is released at the center)
df$x[1] <- 500
df$y[1] <- 500
# Generate the movement trajectory based on random step lengths and turning
# angles
for (i in 1:(nrow(df) - 1)) {
# Determine food availability
f <- raster::extract(food, cbind(df$x[i], df$y[i]))
# Determine the animal's new state
s <- sample_state(state_init, f)
# Sample step lengths from the state-specific gamma distribution
df$stepl[i] <- rgamma(1
, shape = (params$GammaMean[s] / params$GammaSD[s]) ** 2
, scale = params$GammaSD[s] ** 2 / params$GammaMean[s]
)
# Sample (relative) turning angles from the state-specific von mises
# distribution
df$relta[i] <- rvonmises(1
, mu    = params$MisesMean[s]
, kappa = params$MisesCon[s]
)
# Compute the absolute turning angle
df$absta[i] <- absta_init + df$relta[i]
# Compute the new location of the animal
df$x[i + 1] <- df$x[i] + sin(df$absta[i]) * df$stepl[i]
df$y[i + 1] <- df$y[i] + cos(df$absta[i]) * df$stepl[i]
# Store other relevant information
df$food[i]  <- f
df$state[i] <- s
absta_init  <- df$absta[i]
state_init  <- df$state[i]
}
# Return the simulation
return(df)
})
# Chunk 10
# Unnest the data
sims <- unnest(sims, Simulations)
# Take a look at the unnested data
head(sims)
# Chunk 11
# Visualize it
ggplot() +
geom_raster(data = as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
scale_fill_viridis_c(name = "Food Availability") +
geom_point(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.5) +
geom_path(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.5) +
coord_equal() +
theme_minimal() +
guides(color = "none", fill = guide_colourbar(title.position="top", title.hjust = 0.5))
# Visualize it
ggplot() +
geom_raster(data = as.data.frame(food, xy = T), aes(x = x, y = y, fill = layer)) +
scale_fill_viridis_c(name = "Food Availability") +
geom_point(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.5) +
geom_path(data = sims, aes(x = x, y = y, color = as.factor(ID)), size = 0.5) +
coord_equal() +
theme_minimal() +
theme(legend.position = "bottom") +
guides(color = "none", fill = guide_colourbar(title.position="top", title.hjust = 0.5))
p
df_prep$step
df_prep
# Prepare the data (ignore the warning)
df_prep <- prepData(as.data.frame(sims[, c("ID", "x", "y", "food")])
, type       = "UTM"
, coordNames = c("x", "y")
)
df_prep$step
# Histogram of step lengths and turning angles
p1 <- ggplot(df_prep, aes(x = step)) + geom_histogram(col = "white", fill = "cornflowerblue")
p1
# Histogram of step lengths and turning angles
p1 <- ggplot(df_prep, aes(x = step)) +
geom_histogram(col = "white", fill = "cornflowerblue") +
theme_minimal()
p2 <- ggplot(df_prep, aes(x = angle)) +
geom_histogram(col = "white", fill = "cornflowerblue") +
theme_minimal()
ggarrange(p1, p2, nrow = 1)
# Histogram of step lengths and turning angles
p1 <- ggplot(df_prep, aes(x = step)) +
geom_histogram(col = "white", fill = "cornflowerblue") +
theme_minimal() +
xlab("Step Length")
p2 <- ggplot(df_prep, aes(x = angle)) +
geom_histogram(col = "white", fill = "cornflowerblue") +
theme_minimal() +
xlab("Turning Angle")
ggarrange(p1, p2, nrow = 1)
# Histogram of step lengths and turning angles
p1 <- ggplot(df_prep, aes(x = step)) +
geom_histogram(col = "white", fill = "cornflowerblue", bins = 20) +
theme_minimal() +
xlab("Step Length")
p2 <- ggplot(df_prep, aes(x = angle)) +
geom_histogram(col = "white", fill = "cornflowerblue", bins = 20) +
theme_minimal() +
xlab("Turning Angle")
ggarrange(p1, p2, nrow = 1)
################################################################################
####
################################################################################
# Determination of moonlight intensity
# Clear R's brain
rm(list = ls())
# Set working directory
setwd("/home/david/ownCloud/University/15. PhD/Chapter_7")
# Load required packages
library(tidyverse)   # For data wrangling
library(lubridate)   # To handle dates
library(pbmcapply)   # To run stuff in parallel
library(ggdark)      # For dark ggplot themes
# Reload cleaned activity data
dat <- read_csv("03_Data/02_CleanData/ActivityData.csv")
# Compute some useful time-measures
dat <- mutate(dat
, Date = as_date(Timestamp)
, Hour = hour(Timestamp)
)
# We only want to work with the x-axis, thus remove the rest
dat$ActY <- dat$ActZ <- NULL
# For now, focus on one dog only
dat <- subset(dat, DogID == "Abel")
# NEED TO GROUP BY INDIVIDUAL AND COLLAR!
# Check the time-lag between measurements
dat$Lag <- difftime(lead(dat$Timestamp), dat$Timestamp, "mins")
# Visualize activity by hour and day
dat %>%
group_by(Hour, Date) %>%
summarize(ActX = mean(ActX)) %>%
ggplot(aes(x = Hour, y = ActX, col = Date, group = Date)) +
scale_color_viridis_c() +
geom_line(lwd = 0.5, alpha = 0.5) +
dark_theme_bw()
# If the activity measurement is above 15, we deem the animal "active"
dat$Active <- dat$ActX > 15
# Moving window to check 30 minute (i.e. 6*5) activity
dat <- dat[1:10000, ]
dat$Status <- NA
for (i in 1:nrow(dat)) {
if (i < 6) {
dat$Status[i] <- NA
} else {
if (all(dat$Active[(i-5):i])) {
dat$Status[i] <-"Moving"
} else if (all(!dat$Active[(i-5):i])) {
dat$Status[i] <- "Resting"
} else {
dat$Status[i] <- dat$Status[i-1]
}
}
}
View(dat)
ggplot(dat, aes(x = Hour, y = Status, group = Date)) +
geom_point()
ggplot(dat, aes(x = Hour, y = Status, group = Date)) +
geom_point() +
geom_line()
ggplot(dat, aes(x = Hour, y = Status, group = Date, col = Status)) +
geom_point()
View(dat)
# Identify switchpoints
lag(dat$Status) != dat$Status
# Identify switchpoints
dat$Switch <- lag(dat$Status) != dat$Status
hist(subset(dat, Switch)$Hour)
