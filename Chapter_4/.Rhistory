values(map) <- population
return(map)
}
# Try out the functions
par(mfrow = c(1, 2))
population <- initPop(size = 1000, threshold = 0.5)
plot(rasterPop(population), main = "Spatial Population Density")
population <- initPop(size = 50, threshold = 0.5)
plot(rasterPop(population), main = "Spatial Population Density")
# Visualize layer (1 = suitable, 0 = unsuitable)
par(mfrow = c(1, 1))
plot(suit, main = "Habitat Suitability")
# Function to initiate a desired number of individuals across the grid. Multiple
# individuals can inhabit the same cell.
initPop <- function(
size      = NULL # Number of initiated individuals
, threshold = 0.5  # Minimal suitability required
, replace   = T    # Can two or more individuals occupy the sampe cell?
){
pop <- rep(0, ncell(suit))
indices <- which(values(suit) >= threshold)
indivs <- sample(indices, size = size, replace = replace)
tallied <- as.data.frame(table(indivs), stringsAsFactors = F)
pop[as.numeric(tallied$indivs)] <- tallied$Freq
names(pop) <- NULL
return(pop)
}
# Function to represent a population on a map/raster (allows us to plot it)
rasterPop <- function(population = NULL){
map <- raster(suit)
values(map) <- population
return(map)
}
# Try out the functions
par(mfrow = c(1, 2))
population <- initPop(size = 1000, threshold = 0.5)
plot(rasterPop(population), main = "Spatial Population Density")
population <- initPop(size = 50, threshold = 0.5)
plot(rasterPop(population), main = "Spatial Population Density")
par(mfrow = c(1, 1))
################################################################################
#### Functions to Determine Movement & Population Dynamics
################################################################################
# Logit function
logit <- function(x){1 / (1 + exp(-x))}
# Functions that determine the survival probability depending on the habitat
# suitability and population density, as well as the probability of moving into
# a certain cell given the cell's suitability and the cell's population density
Ps <- function(suit, dens, alpha, beta_1, beta_2){
logit(alpha + beta_1 * suit + beta_2 * dens)
}
Pm <- function(suit, dens, alpha, beta_1, beta_2){
logit(alpha + beta_1 * suit + beta_2 * dens)
}
# Plot the reaction functions for some example values
range_suitability <- seq(0, 1, 0.05)
range_density <- seq(0, 100, 1)
par(mfrow = c(2, 2))
plot(Ps(range_suitability, 0, alpha = 0.5, beta_1 = 5, beta_2 = -0.01) ~ range_suitability
, col  = "blue"
, type = "l"
, main = "Survival Probability"
, xlab = "Habitat Suitability"
, ylab = "Ps"
, las  = 1
)
plot(Ps(0, range_density, alpha = 0.5, beta_1 = 5, beta_2 = -0.01) ~ range_density
, col  = "blue"
, type = "l"
, main = "Survival Probability"
, xlab = "Population Density"
, ylab = "Ps"
, las  = 1
)
plot(Pm(range_suitability, 0, alpha = 0, beta_1 = 2, beta_2 = -0.1) ~ range_suitability
, col  = "blue"
, type = "l"
, main = "Movement Probability"
, xlab = "Habitat Suitability"
, ylab = "Pm"
, las  = 1
)
plot(Pm(0, range_density, alpha = 0, beta_1 = 2, beta_2 = -0.1) ~ range_density
, col  = "blue"
, type = "l"
, main = "Movement Probability"
, xlab = "Population Density"
, ylab = "Pm"
, las  = 1
)
par(mfrow = c(1, 1))
# Function that takes the current location of an individual (or multiple
# individuals) and samples a new location based on the habitat suitability and
# population density of neighboring cells. Individuals may also allowed to stay
# in the current cell.
newLoc <- function(
location = NULL  # Current location
, size     = NULL  # Number of sampled locations (i.e. for how many indivs)
, suit     = NULL  # Suitability map
, dens     = NULL  # Density map
, ...
){
# Find neighbors to the specified location (CellID)
neighbors <- adjacent(suit, location, include = T, directions = 8, pairs = F)
# Extract suitability and density at those locations
suit_neighbors <- suit[neighbors]
dens_neighbors <- dens[neighbors]
# Calculate proabilities of moving there
probs <- Pm(suit_neighbors, dens_neighbors, ...)
newloc <- sample(neighbors, size = size, prob = probs, replace = T)
return(newloc)
}
# Try out the function (assume we need to find a new cell for 5 individuals)
newLoc(
location = 1
, size     = 5
, suit     = suit
, dens     = rasterPop(population)
, alpha    = 0
, beta_1   = 0
, beta_2   = 0
)
################################################################################
#### Simulation Function
################################################################################
# Function to simulate population dynamics (for the importance of the alphas and
# betas, check the functions "Ps" and "Pm")
simulate <- function(
timesteps      = NULL  # Number of iterations
, survive_alpha  = NULL  # intercept for Ps
, survive_beta_1 = NULL  # slope_1 for Ps
, survive_beta_2 = NULL  # slope_2 for Ps
, move_alpha     = NULL  # intercept for Ps
, move_beta_1    = NULL  # slope_1 for Pm
, move_beta_2    = NULL  # slope_2 for Pm
, prob_reproduce = NULL
){
# Prepare a matrix with population densities in each cell
pop <- matrix(0, ncol = timesteps, nrow = length(population))
pop[, 1] <- population
# Loop through the different timesteps
for (i in 2:timesteps){
# Identify inhabited cells
inhabited <- which(pop[, i - 1] > 0)
# Loop through inhabited cells and determine survival + reproduction +
# movement
pop_new <- lapply(inhabited, function(x){
# Toss a coin if individuals survive
ps <- Ps(
suit   = suit[x]
, dens   = sum(pop[x, i - 1])
, alpha  = survive_alpha
, beta_1 = survive_beta_1
, beta_2 = survive_beta_2
)
survived <- rbinom(n = 1, size = pop[x, i - 1], prob = ps)
# Toss a coin if individuals reproduce
reproduce <- rbinom(n = 1, size = survived, prob = prob_reproduce)
# Update population size
new <- survived + reproduce
# All individuals now look for a new cell to inhabit
new <- newLoc(
location = x
, size     = new
, suit     = suit
, dens     = rasterPop(pop[, i - 1])
, alpha    = move_alpha
, beta_1   = move_beta_1
, beta_2   = move_beta_2
)
# Return the new population
return(new)
})
# Tallie individauls in different cells
pop_new <- unlist(pop_new)
pop_new <- as.data.frame(table(pop_new), stringsAsFactors = F)
pop[, i][as.numeric(pop_new$pop_new)] <- pop_new$Freq
}
# Return the final population dataset
return(pop)
}
################################################################################
#### Running the Simulation
################################################################################
# Run a test Simulation
sim <- simulate(
timesteps      = 10
, survive_alpha  = 0.5
, survive_beta_1 = 5
, survive_beta_2 = -2
, move_alpha     = 0
, move_beta_1    = 2
, move_beta_2    = -0.1
, prob_reproduce = 0.6
)
# Visualize the result
plot(colSums(sim), type = "b")
plot(rasterPop(sim[, 10]))
# Prepare a dataframe containing all combinations that we want to run the
# simulation for
design <- expand_grid(
survive_beta_1 = c(2, 5, 8)
, move_beta_2    = c(-2, 0, 2)
, replicate      = 1:20
)
# Run the simulation in parallel
design$simulations <- pbmclapply(1:nrow(design)
, mc.cores = detectCores() - 1, ignore.interactive = T, function(x){
# Run simulation
sim <- simulate(
timesteps      = 20
, survive_alpha  = 0.5
, survive_beta_1 = design$survive_beta_1[x]
, survive_beta_2 = -2
, move_alpha     = 0
, move_beta_1    = 2
, move_beta_2    = design$move_beta_2[x]
, prob_reproduce = 0.4
)
# Return the simulation
return(sim)
})
# Look at produced object
print(design)
# Look at produced object
print(design, n = 5)
################################################################################
#### Some Visualizations
################################################################################
# Calculate cumulative population densities over time for each design
design <- mutate(design, densities = map(simulations, function(x){
density <- colSums(x)
density <- data.frame(Year = 1:length(density), Density = density)
return(density)
}))
# Also create a raster of the final populations of each design
design <- mutate(design, raster = map(simulations, function(x){
raster <- rasterPop(x[, ncol(x)])
return(raster)
}))
# Unnest the data
dat <- design %>%
dplyr::select(-simulations, -raster) %>%
unnest(densities)
# Plot it
ggplot(dat, aes(x = Year, y = Density, col = factor(replicate))) +
geom_line(size = 0.3) +
facet_wrap(~ survive_beta_1 + move_beta_2, labeller = label_both, scale = "free") +
scale_color_viridis_d(end = 0.8) +
theme(legend.position = "none")
# We could actually plot how a population developed over time
pop <- design$simulations[[180]]
for (i in 1:20){
map <- rasterPop(pop[, i])
plot(map, zlim = c(0, max(pop)))
Sys.sleep(0.05)
}
# We could actually plot how a population developed over time
pop <- design$simulations[[180]]
for (i in 1:20){
map <- rasterPop(pop[, i])
plot(map, zlim = c(0, max(pop)))
Sys.sleep(0.01)
}
# We could actually plot how a population developed over time
pop <- design$simulations[[180]]
for (i in 1:20){
map <- rasterPop(pop[, i])
plot(map, zlim = c(0, max(pop)))
}
# We could actually plot how a population developed over time
pop <- design$simulations[[180]]
dev.off()
for (i in 1:20){
map <- rasterPop(pop[, i])
plot(map, zlim = c(0, max(pop)))
Sys.sleep(0.01)
}
dev.off()
for (i in 1:20){
map <- rasterPop(pop[, i])
plot(map, zlim = c(0, max(pop)))
Sys.sleep(0.01)
}
# We could actually plot how a population developed over time
pop <- design$simulations[[180]]
dev.new()
for (i in 1:20){
map <- rasterPop(pop[, i])
plot(map, zlim = c(0, max(pop)))
Sys.sleep(0.01)
}
dev.off()
# We could actually plot how a population developed over time
pop <- design$simulations[[180]]
dev.new()
for (i in 1:20){
map <- rasterPop(pop[, i])
plot(map, zlim = c(0, max(pop)))
Sys.sleep(0.1)
}
# We could actually plot how a population developed over time (check external
# plots)
pop <- design$simulations[[180]]
dev.new()
for (i in 1:20){
map <- rasterPop(pop[, i])
plot(map, zlim = c(0, max(pop)))
Sys.sleep(0.1)
}
dev.off()
dev.off()
# We could actually plot how a population developed over time (check external
# plots)
pop <- design$simulations[[180]]
dev.new()
for (i in 1:20){
map <- rasterPop(pop[, i])
plot(map, zlim = c(0, max(pop)))
Sys.sleep(0.3)
}
install.packages("Rage")
library(Rage)
matA <- rbind(c(0.1,   0,   0,   0, 1.4),
c(0.5, 0.2,   0,   0,   0),
c(  0, 0.3, 0.3,   0,   0),
c(  0,   0, 0.4, 0.4, 0.1),
c(  0,   0,   0, 0.1, 0.4))
plot_life_cycle(matA)
matA <- rbind(
c("Fj", "Fa")
, c("Sj", "Sa")
)
matA
plot_life_cycle(matA)
A <- rbind(
c("Fj", "Fa")
, c("Sj", "Sa")
)
plot_life_cycle(matA)
# Define the logit function
logit <- function(x){1 / (1 + exp(-x))}
# Function that determines juvenile survival based on the current temperature
Sj <- function(temp, alpha, beta_1, beta_2){
logit(alpha + beta_1 * temp + beta_2 * temp ** 2)
}
# Function that determines adult fecundity based on the current population size
Fa <- function(popsize, alpha, beta_1, beta_2){
logit(alpha + beta_1 * popsize + beta_2 * popsize ** 2)
}
# Visualize dependencies
temprange <- c(-5:35)
poprange <- c(0:100)
par(mfrow = c(2, 1))
plot(Sj(temprange, -3, 0.3, -0.008) ~ temprange
, col = "blue"
, type = "l"
, xlab = "Temperature"
, ylab = "Sj"
, main = "Temperature Dependence"
, las  = 1
)
plot(Fa(poprange, 3, -0.1, 0) ~ poprange
, col = "blue"
, type = "l"
, xlab = "Population Size"
, ylab = "Fa"
, main = "Density Dependence"
, las  = 1
)
# Simulation function to project our population into the future. Note that I'll
# use the "..." in order to pass the arguments needed by the createMat function,
# i.e. our parameter estimates for density and temperature
simulation <- function(pop, temp, ...){
population <- matrix(NA, nrow = 2, ncol = length(temp))
population[, 1] <- pop
for (i in 2:ncol(population)){
A <- createMat(temp = temp[i], popsize = sum(population[, i - 1]), ...)
population[, i] <- A %*% population[, i - 1]
}
return(population)
}
# Set initial population
pop <- c(10, 10)
# Test if the function works
simulation(
pop
, temp = rnorm(n = 100, mean = 20, sd = 5)
, temp_alpha     = -3
, temp_beta_1    = 0.3
, temp_beta_2    = -0.008
, popsize_alpha  = 3
, popsize_beta_1 = -0.1
, popsize_beta_2 = 0
)
design
# Specify the different treatment combinations, as well as the number of
# replicates
design <- expand_grid(
temp_beta_1    = c(0.2, 0.3, 0.4)
, popsize_beta_1 = c(-0.1, -0.3, -0.5)
, replicate      = 1:100
)
# Load required libraries
library(tidyverse)
print(design, n = 10)
# Specify the different treatment combinations, as well as the number of
# replicates
design <- expand_grid(
temp_beta_1    = c(0.2, 0.3, 0.4)
, popsize_beta_1 = c(-0.1, -0.3, -0.5)
, replicate      = 1:100
)
print(design, n = 10)
print(design, n = 5)
# Check it
head(dat)
# Let's unnest all data and visualize our simulations
dat <- unnest(design, Simulation)
# Clear R's brain
rm(list = ls())
# Load required packages
library(raster)        # To handle spatial data
library(Rcpp)          # For faster point interpolation
library(pbmcapply)     # For parallel computing
library(tidyverse)     # For data wrangling
library(survival)      # To run conditional logistic regression
# Set working directory
setwd("/home/david/ownCloud/University/15. PhD/Chapter_4")
################################################################################
#### Helpful Functions
################################################################################
# Function to interpolate between spatial points
sourceCpp("/home/david/ownCloud/Dokumente/Bibliothek/Wissen/R-Scripts/interpolatepoints.cpp")
# Function to calculate the step length
stepLength <- function(x, y){
length <- sqrt((x - lead(x)) ** 2 + (y - lead(y)) ** 2)
return(length)
}
# Function to calculate the absolute turning angle
absAngle <- function(x, y, rad = T){
xx <- lead(x) - x
yy <- lead(y) - y
xx <- na.omit(xx)
yy <- na.omit(yy)
b <- sign(xx)
b[b == 0] <- 1
tempangle <- b * (yy < 0) * pi + atan(xx / yy)
tempangle[tempangle < 0] <- tempangle[tempangle < 0] + 2 * pi
if (!rad){
tempangle <- tempangle * 180 / pi
}
tempangle <- c(tempangle, NA)
return(tempangle)
}
################################################################################
#### Prepare Data
################################################################################
# Load observed movement data
obs <- read_csv("03_Data/01_RawData/ObservedMovements.csv")
# Specify the different design combinations. Note that a forgiveness of 1 refers
# to a regular step selection function
dat <- expand_grid(
Missingness = seq(0, 0.5, by = 0.1)  # Fraction of the fixes that is removed
, Forgiveness = 1:5                    # Allowed lag of steps (in steps)
, Replicate   = 1:10                   # Number of replicates for each design
)
# Create datasets with rarified observations. That is, randomly remove fixes,
# from 0% to 50%.
dat <- mutate(dat, Observations = map(Missingness, function(x){
obs[sort(sample(1:nrow(obs), size = nrow(obs) * (1 - x))), ]
}))
View(dat)
View(dat[[4]][[1]])
View(dat[[4]][[50]])
View(dat[[4]][[300]])
# Prepare data for step selection analysis
dat <- mutate(dat, SSF = map2(Observations, Forgiveness, function(x, y){
# Calculate temporal difference between steps (in steps)
x$duration <- x$step_number - lag(x$step_number)
x$duration[1] <- 1
# Define bursts. A new burst starts when the temporal lag is more than the
# forgiveness
x$irregular <- x$duration > y
x$burst <- cumsum(x$irregular) + 1
x$irregular <- NULL
# Calculate step length, absolute and relative turning angles for along each
# burst
x <- x %>%
group_by(ID, burst) %>%
nest() %>%
mutate(data = map(data, function(z){
z$sl <- stepLength(z$x, z$y)
z$absta <- absAngle(z$x, z$y)
z$ta <- z$absta - lag(z$absta)
return(z)
})) %>%
unnest(data) %>%
mutate(ta = case_when(
ta < -pi ~ ta + 2 * pi
, ta > +pi ~ ta - 2 * pi
, TRUE ~ ta
)) %>%
dplyr::select(ID, burst, step_number, step_id, everything()) %>%
ungroup()
}))
# Unnest all
test <- dat %>%
dplyr::select(-Observations) %>%
unnest(SSF)
View(interpolatePointsC)
View(test)
