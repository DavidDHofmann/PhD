kml_layer(locs
, size         = 1
, balloon      = T
, LabelScale   = 1.2
, shape        = shape
# , points_names = cams$LocationID
# , colour       = cams$Habitat
)
# kml_layer(lines
#   , colour = "green"
# )
kml_close("Locations.kml")
################################################################################
#### Prepare KML file for Camera Locations
################################################################################
# Clear R's brain
rm(list = ls())
# Change the working directory
setwd("/media/david/USB-STICK1/Cameratrapping")
# Load required packages
library(raster)
library(plotKML)
# Load locations data and camera deployments
locs <- read.csv("Locations.csv", stringsAsFactors = F)
# Make locations spatial
# coordinates(cams) <- c("Longitude", "Latitude")
# crs(cams) <- CRS("+init=epsg:4326")
coordinates(locs) <- c("Longitude", "Latitude")
crs(locs) <- CRS("+init=epsg:4326")
# Visualize
# plot(cams, pch = 20)
# text(cams, "LocationID", pos = 3)
# plot(lines, add = T, col = "blue")
# axis(1)
# axis(2)
locs
locs$Habitat
# Store kml
kml_open("Locations.kml")
kml_layer(cams
, size         = 1
, balloon      = T
, LabelScale   = 1.2
, shape        = shape
, points_names = locs$LocationID
, colour       = locs$Habitat
)
# kml_layer(lines
#   , colour = "green"
# )
kml_close("Locations.kml")
# Store kml
kml_open("Locations.kml")
kml_layer(locs
, size         = 1
, balloon      = T
, LabelScale   = 1.2
, shape        = shape
, points_names = locs$LocationID
, colour       = locs$Habitat
)
# kml_layer(lines
#   , colour = "green"
# )
kml_close("Locations.kml")
locs$Habitat
locs$LocationID
shape
# Specify kml shapes
shape <- "http://maps.google.com/mapfiles/kml/shapes/square.png"
# Store kml
kml_open("Locations.kml")
kml_layer(locs
, size         = 1
, balloon      = T
, LabelScale   = 1.2
, shape        = shape
, points_names = locs$LocationID
, colour       = locs$Habitat
)
# kml_layer(lines
#   , colour = "green"
# )
kml_close("Locations.kml")
library(rgee)
library(reticulate)
ee_Initialize()
aoi <- ee$Geometry$Polygon(
list(
c(21, -17)
, c(21, -20)
, c(28, -20)
, c(28, -17)
)
)
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
filterDate("2021-01-01", "2021-01-30")$
filterBounds(aoi)
# Visualize
map$addLayer(collection)
# Visualize
Map$addLayer(collection)
# Visualize
Map$centerObject(aoi)
Map$addLayer(collection$first())
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
filterDate("2021-01-01", "2021-02-30")$
filterBounds(aoi)
# Visualize
Map$centerObject(aoi, zoom = 10)
Map$addLayer(collection$first())
getQABits <- function(img, qa) {
qa <- sum(2 ** which(rev(unlist(strsplit(as.character(qa), "")) == 1)) - 1)
img$bitwiseAnd(qa)$lt(1)
}
clean <- function(img) {
quality <- img$select("pixel_qa")
quality_mask <- getQABits(quality, "00000100001")
img %>%
ee$Image$updateMask(quality_mask)
}
getQABits <- function(img, qa) {
qa <- sum(2 ** which(rev(unlist(strsplit(as.character(qa), "")) == 1)) - 1)
img$bitwiseAnd(qa)$lt(1)
}
clean <- function(img) {
quality <- img$select("pixel_qa")
quality_mask <- getQABits(quality, "00000100001")
img %>%
ee$Image$updateMask(quality_mask)
}
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
filterDate("2021-01-01", "2021-01-30")$
filterBounds(aoi)$
map(clean)$
median()
# Visualize
Map$centerObject(aoi, zoom = 10)
Map$addLayer(collection$first())
getQABits <- function(img, qa) {
qa <- sum(2 ** which(rev(unlist(strsplit(as.character(qa), "")) == 1)) - 1)
img$bitwiseAnd(qa)$lt(1)
}
clean <- function(img) {
quality <- img$select("pixel_qa")
quality_mask <- getQABits(quality, "00000100001")
img <- img$updateMask(quality_mask)
}
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
filterDate("2021-01-01", "2021-01-30")$
filterBounds(aoi)$
map(clean)$
median()
# Visualize
Map$centerObject(aoi, zoom = 10)
Map$addLayer(collection$first())
getQABits <- function(img, qa) {
qa <- sum(2 ** which(rev(unlist(strsplit(as.character(qa), "")) == 1)) - 1)
img$bitwiseAnd(qa)$lt(1)
}
clean <- function(img) {
values <- img$select("B3")
quality <- img$select("pixel_qa")
quality_mask <- getQABits(quality, "00000100001")
values <- values$updateMask(quality_mask)
}
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
filterDate("2021-01-01", "2021-01-30")$
filterBounds(aoi)$
map(clean)$
median()
# Visualize
Map$centerObject(aoi, zoom = 10)
Map$addLayer(collection$first())
clean <- function(img) {
quality <- img$select("pixel_qa")
quality_mask <- getQABits(quality, "00000100001")
img <- img$updateMask(quality_mask)
}
getQABits <- function(img, qa) {
qa <- sum(2 ** which(rev(unlist(strsplit(as.character(qa), "")) == 1)) - 1)
img$bitwiseAnd(qa)$lt(1)
}
clean <- function(img) {
quality <- img$select("pixel_qa")
quality_mask <- getQABits(quality, "00000100001")
img <- img$updateMask(quality_mask)
}
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
filterDate("2021-01-01", "2021-01-30")$
filterBounds(aoi)$
map(clean)$
median()
# Visualize
Map$centerObject(aoi, zoom = 10)
Map$addLayer(collection)
ee_print(collection)
# Visualize
Map$centerObject(aoi, zoom = 10)
Map$addLayer(collection$select("B3"))
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
filterDate("2021-01-01", "2021-01-30")$
filterBounds(aoi)$
map(clean)$
first()
ee_print(collection)
Map$addLayer(collection$select("B3"))
# Visualize
Map$centerObject(aoi, zoom = 10)
cloudShadowBitMask <- bitwShiftL(1, 3)
cloudBitMask <- bitwShiftL(1, 5)
cloudShadowBitMask
cloudBitMask
cloudShadowBitMask <- bitwShiftL(1, 3)
cloudsBitMask <- bitwShiftL(1, 5)
maskL8sr <- function(img) {
cloudShadowBitMask <- bitwShiftL(1, 3)
cloudsBitMask <- bitwShiftL(1, 5)
qa <- image$select("pixel_qa")
mask <- qa$bitwiseAnd(cloudShadowBitMask)$eq(0)$
And(qa$bitwiseAnd(cloudsBitMask)$eq(0))
image$updateMask(mask)$
divide(10000)$
select("B[0-9]*")$
copyProperties(image, list("system:time_start"))
}
maskL8sr <- function(img) {
cloudShadowBitMask <- bitwShiftL(1, 3)
cloudsBitMask <- bitwShiftL(1, 5)
qa <- image$select("pixel_qa")
mask <- qa$bitwiseAnd(cloudShadowBitMask)$eq(0)$
And(qa$bitwiseAnd(cloudsBitMask)$eq(0))
image$updateMask(mask)$
divide(10000)$
select("B[0-9]*")$
copyProperties(image, list("system:time_start"))
}
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
filterDate("2021-01-01", "2021-01-30")$
filterBounds(aoi)$
map(maskL8sr)$
first()
maskL8sr <- function(image) {
cloudShadowBitMask <- bitwShiftL(1, 3)
cloudsBitMask <- bitwShiftL(1, 5)
qa <- image$select("pixel_qa")
mask <- qa$bitwiseAnd(cloudShadowBitMask)$eq(0)$
And(qa$bitwiseAnd(cloudsBitMask)$eq(0))
image$updateMask(mask)$
divide(10000)$
select("B[0-9]*")$
copyProperties(image, list("system:time_start"))
}
collection <- ee$ImageCollection("LANDSAT/LC08/C01/T1_SR")$
filterDate("2021-01-01", "2021-01-30")$
filterBounds(aoi)$
map(maskL8sr)$
first()
ee_print(collection)
Map$addLayer(collection$select("B3"))
# Visualize
Map$centerObject(aoi, zoom = 10)
# Identify ground truth data
files <- dir(
path       = "03_Data/02_CleanData/GABRIELE"
, pattern    = ".kml$"
, full.names = T
)
# Identify ground truth data
files <- dir(
path       = "03_Data/01_RawData/GABRIELE"
, pattern    = ".kml$"
, full.names = T
)
wd <- "/home/david/ownCloud/University/15. PhD/Chapter_2"
setwd(wd)
# Identify ground truth data
files <- dir(
path       = "03_Data/01_RawData/GABRIELE"
, pattern    = ".kml$"
, full.names = T
)
# Go through the files and load the different land cover training data
classes <- lapply(files, function(x) {
# List available land cover categories and keep only the ones of interest
cats <- ogrListLayers(x)
cats <- cats[cats %in% c("Dry_Pans", "Wet_Pans", "Pools", "Dry_Land")]
date <- ymd(basename(x))
# Go through the categories and load data on the different categories
cats <- lapply(cats, function(y) {
cat <- readOGR(x, layer = y, D3_if_2D3D_points = T)
cat@data <- data.frame(Date = rep(date, nrow(cat)), Class = rep(y, nrow(cat)))
return(cat)
})
# Put them together
cats <- do.call(rbind, cats)
# Return the result
return(cats)
}) %>% do.call(rbind, .)
library(rgdal)
library(tidyverse)
# Go through the files and load the different land cover training data
classes <- lapply(files, function(x) {
# List available land cover categories and keep only the ones of interest
cats <- ogrListLayers(x)
cats <- cats[cats %in% c("Dry_Pans", "Wet_Pans", "Pools", "Dry_Land")]
date <- ymd(basename(x))
# Go through the categories and load data on the different categories
cats <- lapply(cats, function(y) {
cat <- readOGR(x, layer = y, D3_if_2D3D_points = T)
cat@data <- data.frame(Date = rep(date, nrow(cat)), Class = rep(y, nrow(cat)))
return(cat)
})
# Put them together
cats <- do.call(rbind, cats)
# Return the result
return(cats)
}) %>% do.call(rbind, .)
library(lubridate)
wd <- "/home/david/ownCloud/University/15. PhD/Chapter_2"
setwd(wd)
# Identify ground truth data
files <- dir(
path       = "03_Data/01_RawData/GABRIELE"
, pattern    = ".kml$"
, full.names = T
)
# Go through the files and load the different land cover training data
classes <- lapply(files, function(x) {
# List available land cover categories and keep only the ones of interest
cats <- ogrListLayers(x)
cats <- cats[cats %in% c("Dry_Pans", "Wet_Pans", "Pools", "Dry_Land")]
date <- ymd(basename(x))
# Go through the categories and load data on the different categories
cats <- lapply(cats, function(y) {
cat <- readOGR(x, layer = y, D3_if_2D3D_points = T)
cat@data <- data.frame(Date = rep(date, nrow(cat)), Class = rep(y, nrow(cat)))
return(cat)
})
# Put them together
cats <- do.call(rbind, cats)
# Return the result
return(cats)
}) %>% do.call(rbind, .)
# Rename the classes nicely
classes$Class[classes$Class == "Dry_Land"] <- "Dryland"
classes$Class[classes$Class == "Dry_Pans"] <- "Drypan"
classes$Class[classes$Class == "Wet_Pans"] <- "Wetpan"
classes$Class[classes$Class == "Pools"]    <- "Water"
# Convert to sf
classes <- st_as_sf(classes)
library(sf)
# Convert to sf
classes <- st_as_sf(classes)
ee_classes <- sf_as_ee(classes)
library(rgee)
ee_classes <- sf_as_ee(classes)
classes <- st_set_crs(4326)
classes <- st_set_crs(classes, 4326)
ee_classes <- sf_as_ee(classes)
# Specify correct python environment for rgee
ee_install_set_pyenv(
py_path = "/home/david/miniconda3/envs/rgee/bin/python"
, py_env  = "rgee"
)
# Make sure we have all installed for rgee
ee_Initialize()
# Convert to sf
classes <- st_as_sf(classes)
ee_classes <- sf_as_ee(classes)
Map$addLayer(ee_classes)
Map$addLayer(ee_classes$select("geometry"))
Map$centerObject(eeObject = ee_classes)
classes
classes$date <- as.character(classes$date)
as.character(classes$date
as.character(classes$date)
# Convert to sf
classes <- st_as_sf(classes)
classes$date <- as.character(classes$date)
classes$date
# Convert to sf
classes <- st_as_sf(classes)
classes
classes$Date <- as.character(classes$Date)
ee_classes <- sf_as_ee(classes)
Map$centerObject(eeObject = ee_classes)
Map$addLayer(ee_classes)
# Load sentinel 2 TOA data
coll <- ee$ImageCollection("COPERNICUS/S2")$
filterDate("2018-08-15", "2018-08-20")$
filterBounds(classes)$
median()
# Load sentinel 2 TOA data
coll <- ee$ImageCollection("COPERNICUS/S2")$
filterDate("2018-08-15", "2018-08-20")$
median()
# Run svm training
training = coll$sampleRegions(
collection = classes
, properties = list("Class")
, scale = 30
)
# Convert to sf
classes <- st_as_sf(classes)
classes$Date <- NULL
ee_classes <- sf_as_ee(classes)
# Load sentinel 2 TOA data
coll <- ee$ImageCollection("COPERNICUS/S2")$
filterDate("2018-08-15", "2018-08-20")$
median()
# Run svm training
training = coll$sampleRegions(
collection = classes
, properties = list("Class")
, scale = 30
)
classes
# Run svm training
training = coll$sampleRegions(
collection = ee_classes
, properties = list("Class")
, scale = 30
)
# Train
classifier = ee$Classifier$svm(
kernelType = "RBF"
, gamma = 0.5
, cost = 10
)
# Train
ee_print(coll)
# Train
bands <- c("B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B8A", "B9", "B10", "B11", "B12")
trained <- classifier$train(training, "Class", bands)
classified <- coll$classify(train)
classified <- coll$classify(trained)
ee_print(classified)
# Specify classifier
classifier = ee$Classifier$randomForest()
# Train
bands <- c("B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B8A", "B9", "B10", "B11", "B12")
trained <- classifier$train(training, "Class", bands)
classified <- coll$classify(trained)
ee_print(classified)
# Specify classifier
classifier = ee$Classifier$smileRandomForest()
# Specify classifier
classifier = ee$Classifier$smileRandomForest(numberOfTrees = 1000)
# Train
bands <- c("B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B8A", "B9", "B10", "B11", "B12")
trained <- classifier$train(training, "Class", bands)
classified <- coll$classify(trained)
ee_print(classified)
# Convert classes to numeric
classes$Class[classes$Class == "Dry_Land"] <- "1"
classes$Class[classes$Class == "Dry_Pans"] <- "1"
classes$Class[classes$Class == "Wet_Pans"] <- "2"
classes$Class[classes$Class == "Pools"]    <- "2"
classes$Class <- as.numeric(classes$Class)
# Go through the files and load the different land cover training data
classes <- lapply(files, function(x) {
# List available land cover categories and keep only the ones of interest
cats <- ogrListLayers(x)
cats <- cats[cats %in% c("Dry_Pans", "Wet_Pans", "Pools", "Dry_Land")]
date <- ymd(basename(x))
# Go through the categories and load data on the different categories
cats <- lapply(cats, function(y) {
cat <- readOGR(x, layer = y, D3_if_2D3D_points = T)
cat@data <- data.frame(Date = rep(date, nrow(cat)), Class = rep(y, nrow(cat)))
return(cat)
})
# Put them together
cats <- do.call(rbind, cats)
# Return the result
return(cats)
}) %>% do.call(rbind, .)
# Convert classes to numeric
classes$Class[classes$Class == "Dry_Land"] <- "1"
classes$Class[classes$Class == "Dry_Pans"] <- "1"
classes$Class[classes$Class == "Wet_Pans"] <- "2"
classes$Class[classes$Class == "Pools"]    <- "2"
classes$Class <- as.numeric(classes$Class)
# Convert to sf
classes <- st_as_sf(classes)
classes$Date <- as.character(classes$Date)
ee_classes <- sf_as_ee(classes)
# Load sentinel 2 TOA data
coll <- ee$ImageCollection("COPERNICUS/S2")$
filterDate("2018-08-15", "2018-08-20")$
median()
# Sample training locations
training = coll$sampleRegions(
collection = ee_classes
, properties = list("Class")
, scale = 30
)
# Specify classifier
classifier = ee$Classifier$smileRandomForest(numberOfTrees = 1000)
# Train
bands <- c("B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B8A", "B9", "B10", "B11", "B12")
trained <- classifier$train(training, "Class", bands)
classified <- coll$classify(trained)
ee_print(classified)
geoviz_image <- list(bands = c("B4", "B3", "B2"), max = 0.5, gamma = 2)
geoviz_class <- list(min = 0, max = 1, palette = c("red", "green"))
Map$addLayer(classified, visParams = geoviz_class)
geoviz_image <- list(bands = c("B4", "B3", "B2"), max = 0.5, gamma = 2)
geoviz_class <- list(min = 0, max = 2, palette = c("white", "red", "green"))
Map$addLayer(classified, visParams = geoviz_class)
Map$addLayer(classified, visParams = geoviz_class) +
+ Map$addLayer(ee_classes)
